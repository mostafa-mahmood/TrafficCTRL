#=============================== Algorithm Configuration ===============================
# algorithm: fixed_window
# window_size: 60s (duration of each rate limiting window)
# limit: 100 (maximum requests allowed within each window period)
#====================================================================================
# algorithm: sliding_window
# window_size: 60s (duration of the sliding window)
# limit: 100 (maximum requests allowed within any sliding window period)
#====================================================================================
# algorithm: token_bucket
# capacity: 1000 (maximum tokens the bucket can hold at once)
# refill_rate: 50 (number of tokens added per refill_period)
# refill_period: 60s (interval between token refills)
#====================================================================================
# algorithm: leaky_bucket
# capacity: 200 (maximum requests that can be queued before bucket overflows)
# leak_rate: 10 (number of requests processed per leak_period)
# leak_period: 60s (interval between processing batches)
#====================================================================================

#================================ Tenant Configuration ===============================
# tenant_strategy:
#   type: ip || header || cookie || query_parameter
#   key: (required for all types except ip - specifies which field to extract from)
#====================================================================================

#================================ Time format ===============================
# ms -> milliseconds
# s -> seconds
# m -> minutes
# h -> hours
#============================================================================
#===============================  EXAMPLE  ==================================
global: # Applies to ALL incoming requests system-wide across all users and endpoints
  # When this limit is exceeded, emergency flag is set and reputation system starts
  # Requests from Tenants with bad reputation gets denied until the heavy load is off
  enabled: true
  algorithm: token_bucket
  capacity: 30000
  refill_rate: 10000
  refill_period: "1m"

per_tenant: # Applies per individual user/tenant across ALL their requests to any endpoint
  # Ensures fair resource usage - prevents any single user from consuming all system capacity
  enabled: true
  algorithm: sliding_window
  window_size: "1m"
  limit: 300

per_endpoint: # Applies per user/tenant per specific endpoint/path
  # Enables fine-grained control - different rate limits for different API operations
  # Undefined endpoints will have no rate limiting applied
  # Use * wildcard to match path prefixes (e.g., /api/v1/* matches all /api/v1/ subpaths)
  # Rules are evaluated in order - first matching path wins
  rules:
    - path: "/api/v1/auth/login"
      methods: ["POST"] # If omitted, applies to ALL HTTP methods (GET, POST, PUT, DELETE, etc.)
      tenant_strategy:
        type: ip
      algorithm: fixed_window
      window_size: "1m"
      limit: 10

    - path: "/api/v1/auth/register"
      methods: ["POST"]
      tenant_strategy:
        type: ip
      algorithm: fixed_window
      window_size: "1m"
      limit: 10

    - path: "/api/v1/*"
      tenant_strategy:
        type: header
        key: "Authorization"
      algorithm: token_bucket
      capacity: 10
      refill_rate: 10
      refill_period: "1m"

    - path: "/api/uploads/*"
      methods: ["POST", "PUT"]
      tenant_strategy:
        type: header
        key: "x-api-key"
      algorithm: leaky_bucket
      capacity: 20
      leak_rate: 5
      leak_period: "1m"

    - path: "/health"
      bypass: true # Completely skip rate limiting for this endpoint

    - path: "*" # Catch-all rule for any unmatched paths
      tenant_strategy:
        type: header
        key: "x-client-id"
      algorithm: sliding_window
      window_size: "1m"
      limit: 20
